<!DOCTYPE html>
<html lang="zh-cn">
    <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="Rockwinder">
    <meta name="description" content="Rockwinder 的个人博客">
    
    
    <link rel="prev" href="https://rockwinder.github.io/post/macos_gdb_install/" />
    <link rel="next" href="https://rockwinder.github.io/post/how_to_learn_linux_embedded/" />
    <link rel="canonical" href="https://rockwinder.github.io/post/mysql_underlying_architecture/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <title>
        
        
            洞悉MySQL底层架构：游走在缓冲与磁盘之间 | Rockwinder`s Blog
        
    </title>
    <meta name="title" content="洞悉MySQL底层架构：游走在缓冲与磁盘之间 | Rockwinder`s Blog">
    
<link rel="stylesheet" href="/css/main.min.css">


    
    
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/rockwinder.github.io\/"
    },
    "articleSection" : "post",
    "name" : "洞悉MySQL底层架构：游走在缓冲与磁盘之间",
    "headline" : "洞悉MySQL底层架构：游走在缓冲与磁盘之间",
    "description" : "提起MySQL，其实网上已经有一大把教程了，为什么我还要写这篇文章呢，大概是因为网上很多网站都是比较零散，而且描述不够直观，不能系统对MyS",
    "inLanguage" : "zh-cn",
    "author" : "Rockwinder",
    "creator" : "Rockwinder",
    "publisher": "Rockwinder",
    "accountablePerson" : "Rockwinder",
    "copyrightHolder" : "Rockwinder",
    "copyrightYear" : "2020",
    "datePublished": "2020-06-05 14:59:13 \x2b0700 \x2b07",
    "dateModified" : "2020-06-05 14:59:13 \x2b0700 \x2b07",
    "url" : "https:\/\/rockwinder.github.io\/post\/mysql_underlying_architecture\/",
    "wordCount" : "20292",
    "keywords" : [  "Rockwinder`s Blog"]
}
</script>

  </head>
    <body class="">
        <div class="wrapper">
            <nav class="navbar">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
    <div class="container">
        
            <div class="navbar-header header-back2home-logo">
                <span class="logo_mark" >>$</span>
                <a href="https://rockwinder.github.io/">
                    <span class="logo_text" >cd /home/</span>
                    <span class="logo_cursor" ></span>
                </a>
            </div>
        
        <div class="navbar-right">
                
                <span class="menu">
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <span class="divide"></span>
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a>
                </span>
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
     <div class="container">
        <div class="navbar">
            <div class="navbar-header header-logo">
                    <a href="https://rockwinder.github.io/">Rockwinder`s Blog</a>
            </div>
            <div class="navbar-right">
                <div><a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a></div>
                <div class="menu-toggle">
                    <span></span><span></span><span></span>
                </div>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                <nav class="mb-md">
                    
                    
                        <a class="menu-item" href="/post/" title="">
                            <h3>Blog</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/categories/" title="">
                            <h3>Categories</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/tags/" title="">
                            <h3>Tags</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/about/" title="">
                            <h3>About</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                </nav>
        </div>
    </div>
</nav>
            <main class="main">
                <div class="container">
                    
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">洞悉MySQL底层架构：游走在缓冲与磁盘之间</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://rockwinder.github.io/" rel="author">Rockwinder</a> with ♥
                <span class="post-time">
                on <time datetime=2020-06-05 itemprop="datePublished">June 5, 2020</time>
                </span>
                in
                
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        
                        
                        
                          <a href="https://rockwinder.github.io/categories/mysql/"> mysql, </a>
                        
                        
                </span>
                <span class="post-word-count">20292 words</span>
        </div>
    </header>

    <div class="post-content">
        

        
        
            
        

        
        
        
        
        

        
        
        

        <p>提起MySQL，其实网上已经有一大把教程了，为什么我还要写这篇文章呢，大概是因为网上很多网站都是比较零散，而且描述不够直观，不能系统对MySQL相关知识有一个系统的学习，导致不能形成知识体系。为此我撰写了这篇文章，试图让这些底层架构相关知识更加直观易懂：</p>
<ul>
<li>尽量以<code>图文</code>的方式描述技术原理；</li>
<li>涉及到关键的技术，附加<code>官网</code>或者<code>技术书籍</code>来源，方便大家进一步扩展学习；</li>
<li>涉及到的<code>背景知识</code>尽可能做一个交代，比如讨论到log buffer的刷盘方式，延伸一下IO写磁盘相关知识点。</li>
</ul>
<p>好了，MySQL从不会到精通系列马上就要开始了（看完之后还是不会的话..请忽略这句话）。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605095948764-489802624.gif" alt="img" loading="lazy" ></p>
<p>可能会有同学问：为啥不直接学更加先进的TiDB，或者是强大的OceanBase。</p>
<p>其实，MySQL作为老牌的应用场景广泛的关系型开源数据库，其底层架构是很值得我们学习的，吸收其设计精华，那么我们在平时的方案设计工作中也可以借鉴，如果项目中用的是MySQL，那么就能够把数据库用的更好了，了解了MySQL底层的执行原理，对于调优工作也是有莫大帮助的。本文我重点讲述MySQL底层架构，涉及到：</p>
<ul>
<li><strong>内存结构</strong>：<code>buffer pool</code>、<code>log buffer</code>、<code>change buffer</code>，buffer pool的页淘汰机制是怎样的；</li>
<li><strong>磁盘结构</strong>：<code>系统表空间</code>、<code>独立表空间</code>、<code>通用表空间</code>、<code>undo表空间</code>、<code>redo log</code>；</li>
<li>以及<code>IO</code>相关底层原理、查询<code>SQL执行流程</code>、数据<code>页结构</code>和<code>行结构</code>描述、<code>聚集索引</code>和<code>辅助索引</code>的底层数据组织方式、<code>MVCC</code>多版本并发控制的底层实现原理，以及可<code>重复读</code>、<code>读已提交</code>是怎么通过MVCC实现的。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100057210-1236726954.png" alt="img" loading="lazy" ></p>
<p>看完文本文，您将了解到：</p>
<ol>
<li>**整体架构：**InnoDB存储架构是怎样的 (1、MySQL架构)</li>
<li>**工作原理：**查询语句的底层执行流程是怎样的 (2、查询SQL执行流程)</li>
<li>**IO性能：**文件<code>IO操作</code>写磁盘有哪几种方式，有什么IO优化方式 (3.1.2、关于磁盘IO的方式)</li>
<li>**缓存：**<code>InnoDB缓存</code>(buffer pool, log buffer)的刷新方式有哪些（3.1.2.2、innodb_flush_method）</li>
<li>**缓存：**log buffer是在什么时候写入到磁盘的（3.10.2、如何保证数据不丢失 - 其中第四步log buffer持久化到磁盘的时机为）</li>
<li>**缓存：**为什么redo log prepare状态也要写磁盘？（3.10.2、如何保证数据不丢失 - 为什么第二步redo log prepare状态也要写磁盘？）</li>
<li>**缓存：**脏页写盘一般发生在什么时候（3.10.2、如何保证数据不丢失 - 其中第五步：脏页刷新到磁盘的时机为）</li>
<li>**缓存：**为什么唯一索引的更新不可以借助change buffer（3.2、Change Buffer）</li>
<li>**缓存：**<code>log buffer</code>的日志刷盘控制参数<code>innodb_flush_log_at_trx_commit</code>对写性能有什么影响（3.4.1、配置参数）</li>
<li>**缓存：**buffer pool的LRU是如何实现的，为什么要这样实现（3.1.1、缓冲池LRU算法）</li>
<li>**表存储：**系统表空间的结构，MySQL InnoDB磁盘存储格式，各种<code>表空间</code>(系统表空间，独立表空间，通用表空间)的作用和优缺点是什么，<code>ibdata</code>、<code>ibd</code>、<code>frm</code>文件分别是干嘛的（3.5、表空间）</li>
<li>**行字段存储：**底层页和行的存储格式（3.6、InnoDB底层逻辑存储结构）</li>
<li>**行字段存储：**<code>varchar</code>，<code>null</code>底层是如何存储的，最大可用存储多大的长度（3.6.3.1、MySQL中varchar最大长度是多少）</li>
<li>**行字段存储：**行记录太长了，一页存不下，该怎么存储？（3.6.3.2、行记录超过页大小如何存储）</li>
<li>**索引：**数据库<code>索引</code>的组织方式是怎样的，明白为什么要采用<code>B+树</code>，而不是哈希表、二叉树或者B树（3.7、索引 - 为什么MySQL使用B+树）</li>
<li>**索引：**索引组织方式是怎样的，为什么<code>大字段</code>会影响表性能(查询性能，更新性能)（3.7、索引）</li>
<li>**索引：**<code>覆盖索引</code>、<code>联合索引</code>什么情况下会生效（3.7.2、辅助索引）</li>
<li>**索引：**什么是<code>索引下推</code>，索引下推减少了哪方面的开销？（3.7.2、辅助索引 - 索引条件下推）</li>
<li>**索引：**<code>Change Buffer</code>对二级索引DML语句有什么优化（3.2、Change Buffer）</li>
<li>**数据完整性：**MySQL是如何保证数据完整性的，<code>redo log</code>、<code>undo log</code>和<code>buffer pool</code>数据完整性的关键作用分别是什么（3.10.2、如何保证数据不丢失）</li>
<li>**MVCC：**<code>MVCC</code>底层是怎么实现的，可重复读和读已提交是怎么实现的（3.11.2、MVCC实现原理）</li>
<li>双写缓冲区有什么作用（3.9、Doublewrite Buffer）</li>
<li>Redo Log在一个事务中是在什么时候写入的？binlog和Redo Log有什么区别？（3.10.1、Redo Log在事务中的写入时机）</li>
</ol>
<h1 id="1mysql架构">1、MySQL架构</h1>
<p>如下图为MySQL架构涉及到的常用组件：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100120384-71948878.png" alt="img" loading="lazy" ></p>
<h1 id="2查询sql执行流程">2、查询SQL执行流程</h1>
<p>有如下表格：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100145844-526658847.png" alt="img" loading="lazy" ></p>
<p>我们执行以下sql：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t_user <span style="color:#66d9ef">where</span> user_id<span style="color:#f92672">=</span><span style="color:#ae81ff">10000</span>;
</code></pre></div><h2 id="21mysql客户端与服务器建立连接">2.1、MySQL客户端与服务器建立连接</h2>
<p>如下图，建立过程：</p>
<ul>
<li>客户端通过mysql命令发起连接请求；</li>
<li>经过三次握手后与服务端建立TCP连接；</li>
<li>连接器接收到请求之后使用用户密码进行身份验证；</li>
<li>验证通过之后，获取用户的权限信息缓存起来，<strong>该连接后面都是基于该缓存中的权限执行sql</strong>；</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100308502-544112614.png" alt="img" loading="lazy" ></p>
<p>对于Java应用程序来说，一般会把建立好的连接放入数据库连接池中进行复用，只要这个连接不关闭，就会一直在MySQL服务端保持着，可以通过<code>show processlist</code>命令查看，如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100422916-702057597.png" alt="img" loading="lazy" ></p>
<p>注意，这里有个Time，表示这个连接多久没有动静了，上面例子是656秒没有动静，<strong>默认地，如果超过8个小时还没有动静，连接器就会自动断开连接</strong>，可以通过<code>wait_timeout</code>参数进行控制。</p>
<h2 id="22执行sql">2.2、执行SQL</h2>
<p>如下图，执行sql：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100504409-827496817.png" alt="img" loading="lazy" ></p>
<ul>
<li>服务端接收到客户端的查询sql之后，先尝试从查询缓存中查询该sql是否已经有缓存的结果了，如果有则直接返回结果，如果没有则执行下一步；</li>
<li>分析器拿到sql之后会尝试对sql语句进行词法分析和语法分析，校验语法的正确性，通过之后继续往下执行；</li>
<li>优化器拿到分析器的sql之后，开始继续解析sql，判断到需要走什么索引，根据实际情况重写sql，最终生成执行计划；</li>
<li>执行器根据执行计划执行sql，执行之前会先进行操作权限校验；然后根据表存储引擎调用对应接口进行查询数据，这里的扫描行数就是指的接口返回的记录数，执行器拿到返回记录之后进一步加工，如本例子：
<ul>
<li>执行器拿到select * from t_user where user_id=10000的所有记录，在依次判断user_name是不是等于&quot;arthinking&rdquo;，获取到匹配的记录。</li>
</ul>
</li>
</ul>
<h1 id="3innodb引擎架构">3、InnoDB引擎架构</h1>
<p>如下图，为存储引擎的架构：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100545084-730014309.png" alt="img" loading="lazy" ></p>
<p>其实内存中的结构不太好直接观察到，不过磁盘的还是可以看到的，我们找到磁盘中MySQL的数据文件夹看看：</p>
<p><code>cd innodb_data_home_dir</code> 查看MySQL 数据目录：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">|-</span> ib_buffer_pool  <span style="color:#75715e">// 保存缓冲池中页面的表空间ID和页面ID，用于重启恢复缓冲池
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> ib_logfile0  <span style="color:#75715e">// redo log 磁盘文件1
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> ib_logfile1  <span style="color:#75715e">// redo log 磁盘文件2，默认情况下，重做日志存在磁盘的这两个文件中，循环的方式写入重做日志
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> ibdata1  <span style="color:#75715e">// 系统表空间文件
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> ibtmp1  <span style="color:#75715e">// 默认临时表空间文件，可通过innodb_temp_data_file_path属性指定文件位置
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> mysql<span style="color:#f92672">/</span>
<span style="color:#f92672">|-</span> mysql<span style="color:#f92672">-</span>bin<span style="color:#ae81ff">.000001</span>  <span style="color:#75715e">// bin log文件
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> mysql<span style="color:#f92672">-</span>bin<span style="color:#ae81ff">.000001</span>  <span style="color:#75715e">// bin log文件
</span><span style="color:#75715e"></span>...
<span style="color:#f92672">|-</span> mysql<span style="color:#f92672">-</span>bin.index  <span style="color:#75715e">// bin log文件索引
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> mysqld.local.err  <span style="color:#75715e">// 错误日志
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> mysqld.local.pid  <span style="color:#75715e">// mysql进程号
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> performance_schema<span style="color:#f92672">/</span>  <span style="color:#75715e">// performance_schema数据库
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> sys<span style="color:#f92672">/</span>  <span style="color:#75715e">// sys数据库
</span><span style="color:#75715e"></span><span style="color:#f92672">|-</span> test<span style="color:#f92672">/</span>  <span style="color:#75715e">// 数据库文件夹
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|-</span> db.opt  <span style="color:#75715e">// test数据库配置文件，包含数据库字符集属性
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|-</span> t.frm  <span style="color:#75715e">// 数据表元数据文件，不管是使用独立表空间还是系统表空间，每个表都对应有一个
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|-</span> t.ibd  <span style="color:#75715e">// 数据库表独立表空间文件，如果使用的是独立表空间，则一个表对应一个ibd文件，否则保存在系统表空间文件中
</span></code></pre></div><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn1">1]</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html">ib_buffer_pool</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn2">2]</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html">ib_logfile0</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn3">3]</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-temporary-tablespace.html">ibtmp1</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn4">4]</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary-file-removal.html">db.opt</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn5">5]</a></p>
<p>接下来我们逐一来介绍。</p>
<h2 id="31buffer-pool">3.1、buffer pool</h2>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100613634-459652134.png" alt="img" loading="lazy" ></p>
<p><code>buffer pool</code>（<code>缓冲池</code>）是<code>主内存</code>中的一个区域，在InnoDB访问<code>表数据</code>和<code>索引数据</code>的时候，会顺便把对应的数据页缓存到缓冲池中。如果直接从缓冲池中直接读取数据将会加快处理速度。在专用服务器上，通常将80%左右的物理内存分配给缓冲池。</p>
<p>为了提高缓存管理效率，缓冲池把页面链接为列表，使用<code>改进版的LRU算法</code>将很少使用的数据从缓存中老化淘汰掉。</p>
<h3 id="311缓冲池lru算法">3.1.1、缓冲池LRU算法</h3>
<p>通过使用改进版的LRU算法来管理缓冲池列表。</p>
<p>当需要把新页面存储到缓冲池中的时候，将淘汰最近最少使用的页面，并将新页面添加到旧子列表的头部。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100715361-1914179271.png" alt="img" loading="lazy" ></p>
<p>该算法运行方式：</p>
<ul>
<li>默认 3/8缓冲池用于旧子列表；</li>
<li>当新页面如缓冲池时，<strong>首先将其插入旧子列表头部</strong>；</li>
<li>重复访问旧子列表的页面，将使其移动至新子列表的头部；</li>
<li>随着数据库的运行，页面逐步移至列表尾部，缓冲池中未被方位的页面最终将被老化淘汰。</li>
</ul>
<p>相关优化参数：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct</code></a>：控制LRU列表中旧子列表的百分比，默认是37，也就是3/8，可选范围为5~95；</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time"><code>innodb_old_blocks_time</code></a> ：指定第一次访问页面后的时间窗口，该时间窗口内访问页面不会使其移动到LRU列表的最前面。默认是1000，也就是1秒。</li>
</ul>
<blockquote>
<p><strong>innodb_old_blocks_time</strong>很重要，有了这1秒，对于全表扫描，由于是顺序扫描的，一般同一个数据页的数据都是在一秒内访问完成的，不会升级到新子列表中，一直在旧子列表淘汰数据，所以不会影响到新子列表的缓存。</p>
</blockquote>
<h3 id="312关于磁盘io的方式">3.1.2、关于磁盘IO的方式</h3>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100748103-1132308086.png" alt="img" loading="lazy" ></p>
<p><code>O_DIRECT</code>是<code>innodb_flush_method</code>参数的一个可选值。</p>
<p>这里先介绍下和数据库性能密切相关的文件IO操作方法</p>
<h4 id="3121文件io操作方法">3.1.2.1、文件IO操作方法</h4>
<p>数据库系统是基于文件系统的，其性能和设备读写的机制有密切的关系。</p>
<h5 id="open打开文件6httpswwwcnblogscomarthinkingp13034126htmlfn6">open：打开文件[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn6">6]</a></h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">open</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname, <span style="color:#66d9ef">int</span> flags);
</code></pre></div><p>系统调用Open会为该进程一个文件描述符fd，常用的flags如下：</p>
<ul>
<li><code>O_WRONLY</code>：表示我们以&quot;写&quot;的方式打开，告诉内核我们需要向文件中写入数据；</li>
<li><code>O_DSYNC</code>：每次write都等待物理I/O完成，但是如果写操作不影响读取刚写入的数据，则不等待文件属性更新；</li>
<li><code>O_SYNC</code>：每次write都等到物理I/O完成，包括write引起的文件属性的更新；</li>
<li><code>O_DIRECT</code>：执行磁盘IO时绕过缓冲区高速缓存(内核缓冲区)，从用户空间直接将数据传递到文件或磁盘设备，称为直接IO（direct IO）。因为没有了OS cache，所以会O_DIRECT降低文件的顺序读写的效率。</li>
</ul>
<h5 id="write写文件7httpswwwcnblogscomarthinkingp13034126htmlfn7">write：写文件[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn7">7]</a></h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ssize_t <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, size_t count);
</code></pre></div><p>使用open打开文件获取到文件描述符之后，可以调用write函数来写文件，具体表现根据open函数参数的不同而不同弄。</p>
<h5 id="fsync--fdatasync刷新文件8httpswwwcnblogscomarthinkingp13034126htmlfn8">fsync &amp; fdatasync：刷新文件[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn8">8]</a></h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fsync</span>(<span style="color:#66d9ef">int</span> fd);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fdatasync</span>(<span style="color:#66d9ef">int</span> fd);
</code></pre></div><ul>
<li><code>fdatasync</code>：操作完write之后，我们可以调用fdatasync将文件数据块flush到磁盘，只要fdatasync返回成功，则可以认为数据已经写到磁盘了；</li>
<li><code>fsync</code>：与O_SYNC参数类似，fsync还会更新文件metadata到磁盘；</li>
<li><code>sync</code>：sync只是将修改过的块缓冲区写入队列，然后就返回，不等实际写磁盘操作完成；</li>
</ul>
<p><strong>为了保证文件更新成功持久化到硬盘，除了调用write方法，还需要调用fsync。</strong></p>
<p>大致交互流程如下图：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605100819733-748724169.png" alt="img" loading="lazy" ></p>
<p>更多关于磁盘IO的相关内容，可以阅读：<a href="https://medium.com/databasss/on-disk-io-part-1-flavours-of-io-8e1ace1de017">On Disk IO, Part 1: Flavors of IO</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn9">9]</a></p>
<p>**fsync性能问题：**除了刷脏页到磁盘，fsync还会同步文件metadata，而文件数据和metadata通常存放在磁盘不同地方，所以fsync至少需要两次IO操作。</p>
<p><strong>对fsync性能的优化建议</strong>：由于以上性能问题，如果能够减少metadata的更新，那么就可以使用fdatasync了。因此需要确保文件的尺寸在write前后没有发生变化。为此，可以创建固定大小的文件进行写，写完则开启新的文件继续写。</p>
<h4 id="3122innodb_flush_method">3.1.2.2、innodb_flush_method</h4>
<p><code>innodb_flush_method</code>定义用于将数据<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_flush">刷新</a>到<code>InnoDB</code><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_files">数据文件</a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_log_file">日志文件的方法</a>，这可能会影响I/O吞吐量。</p>
<p>以下是具体参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令行格式</td>
<td>&ndash;innodb-flush-method=value</td>
</tr>
<tr>
<td>系统变量</td>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_method">innodb_flush_method</a></td>
</tr>
<tr>
<td>范围</td>
<td>全局</td>
</tr>
<tr>
<td>默认值(Windows)</td>
<td>unbuffered</td>
</tr>
<tr>
<td>默认值(Unix)</td>
<td>fsync</td>
</tr>
<tr>
<td>有效值(Windows)</td>
<td>unbuffered, normal</td>
</tr>
<tr>
<td>有效值(Unix)</td>
<td>fsync, O_DSYNC, littlesync, nosync, O_DIRECT, O_DIRECT_NO_FSYNC</td>
</tr>
</tbody>
</table>
<p>比较常用的是这三种：</p>
<h5 id="fsync">fsync</h5>
<p>默认值，使用<code>fsync()</code>系统调用来flush数据文件和日志文件到磁盘；</p>
<h5 id="o_dsync">O_DSYNC</h5>
<p>由于open函数的O_DSYNC参数在许多Unix系统上都存中问题，因此InnoDB不直接使用O_DSYNC。</p>
<p><code>InnoDB</code>用于<code>O_SYNC</code> 打开和刷新日志文件，<code>fsync()</code>刷新数据文件。</p>
<p>表现为：写日志操作是在write函数完成，数据文件写入是通过<code>fsync()</code>系统调用来完成；</p>
<h5 id="o_direct">O_DIRECT</h5>
<p>使用<code>O_DIRECT</code> （在Solaris上对应为<code>directio()</code>）打开数据文件，并用于<code>fsync()</code>刷新数据文件和日志文件。此选项在某些GNU/Linux版本，FreeBSD和Solaris上可用。</p>
<p>表现为：数据文件写入直接从buffer pool到磁盘，不经过操作系统缓冲，日志还是需要经过操作系统缓存；</p>
<h5 id="o_direct_no_fsync">O_DIRECT_NO_FSYNC</h5>
<p>在刷新I/O期间<code>InnoDB</code>使用<code>O_DIRECT</code>，并且每次write操作后跳过<code>fsync()</code>系统调用。</p>
<p>此设置适用于某些类型的文件系统，但不适用于其他类型的文件系统。例如，它不适用于XFS。如果不确定所使用的文件系统是否需要fsync()（例如保留所有文件元数据），请改用O_DIRECT。</p>
<p>如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101409686-1963354893.png" alt="img" loading="lazy" ></p>
<blockquote>
<p><strong>为什么使用了O_DIRECT配置后还需要调用fsync()?</strong></p>
<p>参考MySQL的这个bug：<a href="https://bugs.mysql.com/bug.php?id=45892">Innodb calls fsync for writes with innodb_flush_method=O_DIRECT</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn10">10]</a></p>
<p>Domas进行的一些测试表明，如果没有fsync，某些文件系统（XFS）不会同步元数据。如果元数据会更改，那么您仍然需要使用fsync（或O_SYNC来打开文件）。</p>
<p>例如，如果在启用O_DIRECT的情况下增大文件大小，它仍将写入文件的新部分，但是由于元数据不能反映文件的新大小，因此如果此刻系统发生崩溃，文件尾部可能会丢失。</p>
<p>为此：<strong>当重要的元数据发生更改时，请继续使用fsync或除O_DIRECT之外，也可以选择使用O_SYNC。</strong></p>
</blockquote>
<p>MySQL从v5.6.7起提供了<code>O_DIRECT_NO_FSYNC</code>选项来解决此类问题。</p>
<h2 id="32change-buffer">3.2、Change Buffer</h2>
<p>change buffer是一种特殊的数据结构，当<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_secondary_index">二级索引</a>页(非唯一索引)不在<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool">缓冲池中</a>时，它们会缓存这些更改 。当页面通过其他读取操作加载到缓冲池中时，再将由<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html"><code>INSERT</code></a>，<a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"><code>UPDATE</code></a>或<a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"><code>DELETE</code></a>操作（DML）产生的change buffer合并到buffer pool的数据页中。</p>
<blockquote>
<p><strong>为什么唯一索引不可以使用chage buffer？</strong></p>
<p>针对唯一索引，如果buffer pool不存在对应的数据页，还是需要先去磁盘加载数据页，才能判断记录是否重复，这一步避免不了。</p>
<p>而普通索引是非唯一的，插入的时候以相对随机的顺序发生，删除和更新也会影响索引树中不相邻的二级索引树，<strong>通过使用合并缓冲，避免了在磁盘产生大量的随机IO访问获取普通索引页。</strong></p>
<p><strong>问题</strong></p>
<p>当有许多受影响的行和许多辅助索引要更新时，change buffer合并可能需要几个小时，在此期间，I/O会增加，可能会导致查询效率大大降低，即使在事务提交之后，或者服务器重启之后，change buffer合并操作也会继续发生。相关阅读：<a href="https://dev.mysql.com/doc/refman/5.7/en/forcing-innodb-recovery.html">Section 14.22.2, “Forcing InnoDB Recovery”</a></p>
</blockquote>
<h2 id="33自适应哈希索引">3.3、自适应哈希索引</h2>
<p>自适应哈希索引功能由<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index"><code>innodb_adaptive_hash_index</code></a>变量启用 ，或在服务器启动时由<code>--skip-innodb-adaptive-hash-index</code>禁用。</p>
<h2 id="34log-buffer">3.4、Log Buffer</h2>
<p>log buffer(日志缓冲区)用于保存要写入磁盘上的log file(日志文件)的数据。日志缓存区的内容会定期刷新到磁盘。</p>
<p>日志缓冲区大小由<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size"><code>innodb_log_buffer_size</code></a>变量定义 。默认大小为16MB。较大的日志缓冲区可以让大型事务在提交之前无需将redo log写入磁盘。</p>
<p>如果您有更新，插入或者删除多行的事务，尝试增大日志缓冲区的大小可以节省磁盘I/O。</p>
<h3 id="341配置参数">3.4.1、配置参数</h3>
<p><strong>innodb_flush_log_at_trx_commit</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit"><code>innodb_flush_log_at_trx_commit</code></a> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘。</p>
<p>该参数控制是否严格存储ACID还是尝试获取更高的性能，可以通过该参数获取更好的性能，但是会导致在系统崩溃的过程中导致数据丢失。</p>
<p>可选参数：</p>
<ul>
<li>0，事务提交之后，日志只记录到log buffer中，每秒写一次日志到缓存并刷新到磁盘，尚未刷新的日志可能会丢失；</li>
<li>1，要完全符合ACID，必须使用该值，表示日志在每次事务提交时写入缓存并刷新到磁盘；</li>
<li>2，每次事务提交之后，日志写到page cache，每秒刷一次到磁盘，尚未刷新的日志可能会丢失；</li>
</ul>
<p><strong>innodb_flush_log_at_timeout</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout"><code>innodb_flush_log_at_timeout</code></a> 变量控制日志刷新频率。可让您将日志刷新频率设置为<em><code>N</code></em>秒（其中<em><code>N</code></em>为<code>1 ... 2700</code>，默认值为1）</p>
<blockquote>
<p>为了保证数据不丢失，请执行以下操作：</p>
<ul>
<li>如果启用了binlog，则设置：sync_binlog=1;</li>
<li>innodb_flush_log_at_trx_commit=1;</li>
</ul>
</blockquote>
<p>配置效果如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101002665-1552374135.png" alt="img" loading="lazy" ></p>
<h2 id="35表空间">3.5、表空间</h2>
<p>一个<code>InnoDB</code>表及其索引可以在建在<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间</a>中，或者是在一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_file_per_table">独立表空间</a> 中，或在 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_general_tablespace">通用表空间</a>。</p>
<ul>
<li>当<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>启用时，通常是将表存放在独立表空间中，这是默认配置；</li>
<li>当<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>禁用时，则会在系统表空间中创建表；</li>
<li>要在通用表空间中创建表，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html"><code>CREATE TABLE ... TABLESPACE</code></a>语法。有关更多信息，请参见官方文档 <a href="https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html">14.6.3.3 General Tablespaces</a>。</li>
</ul>
<p>表空间概览图：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101025183-206386293.png" alt="img" loading="lazy" ></p>
<h3 id="表空间涉及的文件">表空间涉及的文件</h3>
<p>相关文件默认在磁盘中的<code>innodb_data_home_dir</code>目录下：</p>
<pre><code>|- ibdata1  // 系统表空间文件
|- ibtmp1  // 默认临时表空间文件，可通过innodb_temp_data_file_path属性指定文件位置
|- test/  // 数据库文件夹
    |- db.opt  // test数据库配置文件，包含数据库字符集属性
    |- t.frm  // 数据表元数据文件，不管是使用独立表空间还是系统表空间，每个表都对应有一个
    |- t.ibd  // 数据库表独立表空间文件，如果使用的是独立表空间，则一个表对应一个ibd文件，否则保存在系统表空间文件中
</code></pre><p><strong>frm文件</strong></p>
<p>创建一个<code>InnoDB</code>表时，MySQL 在数据库目录中创建一个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_frm_file">.frm文件</a>。frm文件包含MySQL表的元数据(如表定义)。每个InnoDB表都有一个.frm文件。</p>
<p>与其他MySQL存储引擎不同， <code>InnoDB</code>它还在<code>系统表空间</code>内的自身内部数据字典中编码有关表的信息。MySQL删除表或数据库时，将删除一个或多个<code>.frm</code>文件以及<code>InnoDB</code>数据字典中的相应条目。</p>
<p>因此，在InnoDB中，您不能仅通过移动<code>.frm</code> 文件来移动表。有关移动<code>InnoDB</code> 表的信息，请参见官方文档<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-migration.html">14.6.1.4 Moving or Copying InnoDB Tables</a>。</p>
<p><strong>ibd文件</strong></p>
<p>对于在独立表空间创建的表，还会在数据库目录中生成一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ibd_file">.ibd</a>表空间文件。</p>
<p>在<code>通用表空间</code>中创建的表在现有的常规表空间 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ibd_file">.ibd文件</a>中创建。常规表空间文件可以在<strong>MySQL数据目录内部或外部创建</strong>。有关更多信息，请参见官方文档<a href="https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html">14.6.3.3 General Tablespaces</a>。</p>
<p><strong>ibdata文件</strong></p>
<p>系统表空间文件，在 <code>InnoDB</code>系统表空间中创建的表在ibdata中创建。</p>
<h3 id="351系统表空间">3.5.1、系统表空间</h3>
<p>系统表空间由一个或多个数据文件(ibdata文件)组成。其中包含与<code>InnoDB</code>相关对象有关的元数据（<code>InnoDB</code> <strong>数据字典</strong> <strong>data dictionary</strong>），以及<strong>更改缓冲区</strong>（<strong>change buffer</strong>）， <strong>双写缓冲区</strong>（<strong>doublewrite buffer</strong>）和<strong>撤消日志</strong>（<strong>undo logs</strong>）的存储区 。</p>
<p><code>InnoDB</code> 如果表是在系统表空间中创建的，则系统表空间中也包含表的表数据和索引数据。</p>
<h4 id="系统表空间的问题">系统表空间的问题</h4>
<p>在MySQL 5.6.7之前，默认设置是将所有<code>InnoDB</code>表和索引保留 在系统表空间内，这通常会导致该文件变得非常大。因为系统表空间永远不会缩小，所以如果先加载然后删除大量临时数据，则可能会出现存储问题。</p>
<p>在MySQL 5.7中，默认设置为 <strong>独立表空间</strong>模式，其中每个表及其相关索引存储在单独的 <strong>.ibd文件中</strong>。此默认设置使使用**<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_barracuda">Barracuda</a>**文件格式的<code>InnoDB</code>功能更容易使用，例如表**压缩**，**页外列的**有效存储以及大索引键前缀（<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix"><code>innodb_large_prefix</code></a>）。</p>
<p>将所有表数据保留在系统表空间或单独的 <code>.ibd</code>文件中通常会对存储管理产生影响。</p>
<p><code>InnoDB</code>在MySQL 5.7.6中引入了<strong>通用表空间</strong>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn11">11]</a>，这些表空间也由<code>.ibd</code>文件表示 。通用表空间是使用<a href="https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html"><code>CREATE TABLESPACE</code></a>语法创建的共享表空间。它们可以在MySQL数据目录之外创建，能够容纳多个表，并支持所有行格式的表。</p>
<h3 id="352独立表空间">3.5.2、独立表空间</h3>
<p>MySQL 5.7中，配置参数：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>，默认处于启用状态，这是一个重要的配置选项，会影响<code>InnoDB</code>文件存储，功能的可用性和I/O特性等。</p>
<p>启用之后，每个表的数据和索引是存放在单独的.ibd文件中的，而不是在系统表空间的共享ibdata文件中。</p>
<h4 id="优点">优点</h4>
<ul>
<li>
<p>您可以更加灵活的选择</p>
<pre><code>数据压缩
</code></pre><p>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn12">12]</a></p>
<p>的行格式，如：</p>
<ul>
<li>默认情况下（innodb_page_size=16K），<code>前缀索引</code>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn13">13]</a>最多包含768个字节。如果开启innodb_large_prefix，且Innodb表的存储行格式为 DYNAMIC 或 COMPRESSED，则前缀索引最多可包含3072个字节，前缀索引也同样适用；</li>
</ul>
</li>
<li>
<p><code>TRUNCATE TABLE</code>执行的更快，并且回收的空间不会继续保留，而是让操作系统使用；</p>
</li>
<li>
<p>可以在单独的存储设备上创建每表文件表空间数据文件，以进行I / O优化，空间管理或备份。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html">14.6.1.2 Creating Tables Externally</a>；</p>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>独立表空间中的未使用空间只能由同一个表使用，如果管理不当，会造成空间浪费；</li>
<li>多个表需要刷盘，只能执行多次fsync，无法合并多个表的写操作，这可能会导致更多的fsync操作总数；</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html"><strong>mysqld</strong></a>必须为每个表文件空间保留一个打开的文件句柄，如果表数量多，可能会影响性能；</li>
<li>每个表都需要自己的数据文件，需要更多的文件描述符；</li>
</ul>
<blockquote>
<p>即使启用了innodb_file_per_table参数，每张表空间存放的只是数据、索引和插入缓存Bitmap页，其他数据如回滚信息、插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间中。</p>
</blockquote>
<h3 id="353通用表空间">3.5.3、通用表空间</h3>
<p>通用表空间使用<a href="https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html"><code>CREATE TABLESPACE</code></a>语法创建。</p>
<p>类似于系统表空间，通用表空间是共享表空间，可以存储多个表的数据。</p>
<p>通用表空间比独立表空间具有潜在的内存优势，服务器在表空间的生存期内将表空间元数据保留在内存中。一个通用表空间通常可以存放多个表数据，消耗更少的表空间元数据内存。</p>
<p>数据文件可以放置在MySQL数据目录或独立于MySQL数据目录。</p>
<h3 id="354undo表空间">3.5.4、undo表空间</h3>
<p>undo表空间包含undo log。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_rollback_segments"><code>innodb_rollback_segments</code></a>变量定义分配给每个撤消表空间的回滚段的数量。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log">undo log</a>可以存储在一个或多个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace">undo表空间</a>中，而不是<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间中</a>。</p>
<p>在默认配置中，撤消日志位于<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间</a>中。SSD存储更适合undo log的I/O模式，为此，可以把undo log存放在有别于系统表空间的ssd硬盘中。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces"><code>innodb_undo_tablespaces</code></a> 配置选项控制undo表空间的数量。</p>
<h3 id="355临时表空间">3.5.5、临时表空间</h3>
<p>由用户创建的非压缩临时表和磁盘内部临时表是在共享临时表空间中创建的。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_temp_data_file_path"><code>innodb_temp_data_file_path</code></a> 配置选项指定零时表空间文件的路径，如果未指定，则默认在 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir</code></a>目录中创建一个略大于12MB 的自动扩展数据文件<code>ibtmp1</code> 。</p>
<p>使用<code>ROW_FORMAT=COMPRESSED</code>属性创建的压缩临时表，是在独立表空间中的临时文件目录中创建的 。</p>
<p>服务启动的时候创建临时表空间，关闭的时候销毁临时表空间。如果临时表空间创建失败，则意味着服务启动失败。</p>
<h2 id="36innodb底层逻辑存储结构">3.6、InnoDB底层逻辑存储结构</h2>
<p>在介绍索引之前，我们有必要了解一下InnoDB底层的逻辑存储结构，因为索引是基于这个底层逻辑存储结构创建的。截止到目前，我们所展示的都仅仅是物理磁盘中的逻辑视图，接下来我们就来看看底层的视图。</p>
<h3 id="361ibd文件组织结构">3.6.1、ibd文件组织结构</h3>
<p>现在<strong>我们打开一个表空间ibd文件，看看里面都是如何组织数据的？</strong></p>
<p>如下图，表空间由段(segment)、区(extent)、页(page)组成。</p>
<p>InnoDB最小的存储单位是页，默认每个页大小是16k。</p>
<p>而InnoDB存储引擎是面向行的(row-oriented)，数据按行进行存放，每个页规定最多允许存放的行数=16k/2 - 200，即7992行。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101055058-1066273834.png" alt="img" loading="lazy" ></p>
<p>段：如数据段、索引段、回滚段等。<strong>InnoDB存储引擎是B+树索引组织的</strong>，所以数据即索引，索引即数据。B+树的叶子节点存储的都是数据段的数据。</p>
<h3 id="362数据页结构14httpswwwcnblogscomarthinkingp13034126htmlfn14">3.6.2、数据页结构[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn14">14]</a></h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fil Header</td>
<td>38 byte</td>
<td>页的基本信息，如所属表空间，上一页和下一页指针。</td>
</tr>
<tr>
<td>Page Header</td>
<td>56 byte</td>
<td>数据页专有的相关信息</td>
</tr>
<tr>
<td>Infimun + Supremum</td>
<td>26 byte</td>
<td>两个虚拟的行记录，用于限定记录的边界</td>
</tr>
<tr>
<td>User Records</td>
<td>动态分配</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>动态调整</td>
<td>尚未使用的页空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>动态调整</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td>Fil Trailer</td>
<td>8 byte</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>关于Infimun和Supremum：首次创建索引时，InnoDB会在根页面中自动设置一个最小记录和一个最高记录，并且永远不会删除它们。最低记录和最高记录可以视为索引页开销的一部分。最初，它们都存在于根页面上，但是随着索引的增长，最低记录将存在于第一或最低叶子页上，最高记录将出现在最后或最大关键字页上。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101118060-1033143498.png" alt="img" loading="lazy" ></p>
<h3 id="363行记录结构描述15httpswwwcnblogscomarthinkingp13034126htmlfn15">3.6.3、行记录结构描述[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn15">15]</a></h3>
<p>先来讲讲Compact行记录格式，Compact是MySQL5.0引入的，设计目标是高效的存储数据，让一个页能够存放更多的数据，从而实现更快的B+树查找。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>变长字段长度列表</td>
<td>字段大小最多用2个字节表示，也就是最多限制长度：2^16=65535个字节；字段大小小于255字节，则用1个字节表示；</td>
</tr>
<tr>
<td>NULL标志位</td>
<td>记录该行哪些位置的字段是null值</td>
</tr>
<tr>
<td>记录头信息</td>
<td>记录头信息信息，固定占用5个字节</td>
</tr>
<tr>
<td>列1数据</td>
<td>实际的列数据，NULL不占用该部分的空间</td>
</tr>
<tr>
<td>列2数据</td>
<td></td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>记录头用于将连续的记录链接在一起，并用于行级锁定。</strong></p>
<p>每行数据除了用户定义的列外，还有两个隐藏列：</p>
<ul>
<li>6个字节的事务ID列；</li>
<li>7个字节的回滚指针列；</li>
<li>如果InnoDB没有指定主键，还会增加一个6个字节的rowid列；</li>
</ul>
<p>而记录头信息包[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn16">16]</a>含如下内容：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>1</td>
<td>未知</td>
</tr>
<tr>
<td>()</td>
<td>1</td>
<td>未知</td>
</tr>
<tr>
<td>deleted_flag</td>
<td>1</td>
<td>该行是否已被删除</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>如果该记录是预定义的最小记录，则为1</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的排序号</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000 普通，001 B+树节点指针，010 Infimum，011 Supremum，1xx 保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>指向页中下一条记录</td>
</tr>
</tbody>
</table>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101555504-1521776650.png" alt="img" loading="lazy" ></p>
<blockquote>
<p>更详细的页结构参考官网：<a href="https://dev.mysql.com/doc/internals/en/innodb-page-structure.html">22.2 InnoDB Page Structure</a></p>
<p>更详细的行结构参考官网：<a href="https://dev.mysql.com/doc/internals/en/innodb-record-structure.html">22.1 InnoDB Record Structure</a></p>
<p>更详细的行格式参考官网：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html">14.11 InnoDB Row Formats</a></p>
</blockquote>
<p>根据以上格式，可以得出数据页内的记录组织方式：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101614121-1476589124.png" alt="img" loading="lazy" ></p>
<h4 id="3631mysql中varchar最大长度是多少">3.6.3.1、MySQL中varchar最大长度是多少</h4>
<p>上面表格描述我们知道，一个字段最长限制是65535个字节，这是存储长度的限制。</p>
<p>而MySQL中对存储是有限制的，具体参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html">8.4.7 Limits on Table Column Count and Row Size</a></p>
<ul>
<li>MySQL对每个表有4096列的硬限制，但是对于给定的表，有效最大值可能会更少；</li>
<li><strong>MySQL表的每行行最大限制为65,535字节</strong>，这是逻辑的限制；实际存储的时候，表的物理最大行大小略小于页面的一半。如果一行的长度少于一页的一半，则所有行都将存储在本地页面内。如果它超过一页的一半，那么将选择可变长度列用于外部页外存储，直到该行大小控制在半页之内为止。</li>
</ul>
<p>而实际能够存储的字符是跟编码有关的。</p>
<blockquote>
<p>背景知识：</p>
<ul>
<li>MySQL 4.0版本以下，varchar(10)，代表10个<strong>字节</strong>，如果存放UTF8汉字，那么只能存3个（每个汉字3字节）；</li>
<li>MySQL 5.0版本以上，varchar(10)，指的是10个<strong>字符</strong>，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放10个，最大大小是65532<strong>字节</strong>；</li>
</ul>
<p><strong>因此，Mysql5根据编码不同,存储大小也不同。</strong></p>
</blockquote>
<p>那么假设我们使用的是utf8编码，那么每个字符最多占用3个字节，也就是最多定义varchar(21845)个字符，如果是ascii编码，一个字符相当于一个字节，最多定义varchar(65535)个字符，下面我们验证下。</p>
<p>我们尝试创建一个这样的字段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>t10<span style="color:#f92672">`</span> ( <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
                  <span style="color:#f92672">`</span>a<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
                  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>)
                 ) ENGINE<span style="color:#f92672">=</span>InnoDB CHARSET<span style="color:#f92672">=</span>ascii ROW_FORMAT<span style="color:#f92672">=</span>Compact;


<span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t10 <span style="color:#66d9ef">add</span> <span style="color:#f92672">`</span>str<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">21845</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>;

<span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t10 <span style="color:#66d9ef">add</span> <span style="color:#f92672">`</span>str<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">65535</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>;
</code></pre></div><p>发现提示这个错误：</p>
<pre><code>mysql&gt; alter table t10 add `str` varchar(65535) DEFAULT NULL;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
</code></pre><p>原因是按照以上的行格式介绍，<code>变长字段长度列表</code>记录也需要占用空间，占用2个字节，另外这里是允许为空字段，在8位之内，所以NULL标志位占用1个字节，所以我们总共可以存储的字符数是：</p>
<blockquote>
<p>65535 - 2 - 2 - 4 - 4=65534</p>
<p>其中 -2 个字节表示变长字段列表，-1表示NULL标志位，两个-4表示两个int类型字段占用大小</p>
</blockquote>
<p>所以实际上能够容纳的varchar大小为：65524，我们验证下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101639352-1415900470.png" alt="img" loading="lazy" ></p>
<h4 id="3632行记录超过页大小如何存储">3.6.3.2、行记录超过页大小如何存储</h4>
<p>MySQL表的内部表示具有65,535字节的最大行大小限制。<code>InnoDB</code> 对于4KB，8KB，16KB和32KB <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size"><code>innodb_page_size</code></a> 设置，表的最大行大小（适用于本地存储在数据库页面内的数据）略小于页面的一半 。如果包含 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_variable_length_type">可变长度列</a>的<code>InnoDB</code> 行超过最大行大小，那么将选择可变长度列用于外部页外存储。</p>
<p>可变长度列由于太长而无法容纳在B树页面上，这个时候会把可变长度列存储在单独分配的磁盘页面上，这些页面称为<code>溢出页面</code>，这些列称为<code>页外列</code>。页外列的值存储在由溢出页面构成的<code>单链接列表</code>中。</p>
<p><code>InnoDB</code>存储引擎支持四种行格式：<code>REDUNDANT</code>，<code>COMPACT</code>， <code>DYNAMIC</code>，和<code>COMPRESSED</code>。不同的行格式，对溢出的阈值和处理方式有所区别，详细参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html#innodb-row-format-compact">14.11 InnoDB Row Formats</a>。</p>
<p><strong>COMPACT行格式处理方式</strong></p>
<p>使用<code>COMPACT</code>行格式的表将前768个字节的变长列值（<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html"><code>VARBINARY</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html"><code>TEXT</code></a>类型）存储在<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_b_tree">B树</a>节点内的索引记录中，其余的存储在溢出页上。</p>
<p>如果列的值等于或小于<strong>768个字节</strong>，则不使用溢出页，因此可以节省一些I / O。</p>
<p>如果查过了768个字节，那么会按照如下方式进行存储：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101707698-697457189.png" alt="img" loading="lazy" ></p>
<p><strong>DYNAMIC行格式处理方式</strong></p>
<p><code>DYNAMIC</code>行格式提供与<code>COMPACT</code>行格式相同的存储特性，但改进了超长可变长度列的存储能力和支持大索引键前缀。</p>
<p><code>InnoDB</code> 可以完全在页外存储过长的可变长度列值（针对 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html"><code>VARBINARY</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html"><code>TEXT</code></a>类型），而聚集索引记录仅包含指向溢出页的20字节指针。大于或等于768字节的固定长度字段被编码为可变长度字段。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101729361-2077095807.png" alt="img" loading="lazy" ></p>
<blockquote>
<p><strong>表中大字段引发的问题</strong></p>
<p>如果一个表中有过多的可变长度大字段，导致一行记录太长，而整个时候使用的是COMPACT行格式，那么就可能会插入数据报错。</p>
<p>如，页面大小事16k，根据前面描述我们知道，MySQL限制一页最少要存储两行数据，如果很多可变长度大字段，在使用COMPACT的情况下，仍然会把大字段的前面768个字节存在索引页中，可以算出最多支持的大字段：<code>1024 * 16 / 2 / 768 = 10.67</code>，那么超过10个可变长度大字段就会插入失败了。</p>
<p>这个时候可以把row format改为：DYNAMIC。</p>
</blockquote>
<h2 id="37索引">3.7、索引</h2>
<p>前面我们了解了InnoDB底层的存储结构，即：以B+树的方式组织数据页。另外了解了数据页中的数据行的存储方式。</p>
<p>而构建B+树索引的时候必须要选定一个或者多个字段作为索引的值，如果索引选择的是主键，那么我们就称为聚集索引，否则就是二级索引。</p>
<blockquote>
<p>为什么MySQL使用B+树？</p>
<ul>
<li>哈希表虽然可以提供O(1)的单行数据操作性能，但却不能很好的支持排序和范围查找，会导致全表扫描；</li>
<li>B树可以再非叶子节点存储数据，但是这可能会导致查询连续数据的时候增加更多的I/O操作；</li>
<li>而B+树数据都存放在叶子节点，叶子节点通过指针相互连接，可以减少顺序遍历时产生的额外随机I/O</li>
</ul>
<p>更新详细解释: <a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a>[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn17">17]</a></p>
</blockquote>
<h3 id="371聚集索引">3.7.1、聚集索引</h3>
<p>了解到上面的底层逻辑存储结构之后，我们进一步来看看InnoDB是怎么通过B+树来组织存储数据的。</p>
<p>首先来介绍下聚集索引。</p>
<h4 id="聚集索引">聚集索引</h4>
<p>主键索引的InnoDB术语。</p>
<p>下面我们创建一张测试表，并插入数据，来构造一颗B+树：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> t20 (
id int <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
a int <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
b int,
<span style="color:#66d9ef">c</span> int,
<span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>)
) ENGINE<span style="color:#f92672">=</span>InnoDB;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</code></pre></div><p>可以看到，虽然我们是id乱序插入的，但是插入之后查出来的确是排序好的：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101757741-917943669.png" alt="img" loading="lazy" ></p>
<p>这个排序就是B+索引树构建的。</p>
<p>我们可以通过这个<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">在线的动态演示工具</a>来看看B+树的构造过程，最终结果如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101817655-1704264950.png" alt="img" loading="lazy" ></p>
<blockquote>
<p>实际存放在数据库中的模型因页面大小不一样而有所不同，这里为了简化模型，我们按照B+树的通用模型来解释数据的存储结构。</p>
</blockquote>
<p>类似的，我们的数据也是这种组织形式的，该B+树中，我们以主键为索引进行构建，并且把完整的记录存到对应的页下面：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101848746-490320038.png" alt="img" loading="lazy" ></p>
<p>其中蓝色的是索引页，橙色的是数据页。</p>
<p>每个页的大小默认为16k，如果插入新的数据行，这个时候就要申请新的数据页了，然后挪动部分数据过去，重新调整B+树，这个过程称为<code>页分裂</code>，这个过程会影响性能。</p>
<p>相反的，如果<code>InnoDB</code>索引页的填充因子下降到之下<code>MERGE_THRESHOLD</code>，默认情况下为50％（如果未指定），则<code>InnoDB</code>尝试收缩索引树以释放页面。</p>
<p>自增主键的插入是递增顺序插入的，每次添加记录都是追加的，不涉及到记录的挪动，不会触发叶子节点的分裂，而一般业务字段做主键，往往都不是有序插入的，写成本比较高，所以我们<strong>更倾向于使用自增字段作为主键。</strong></p>
<h4 id="聚集索引注意事项">聚集索引注意事项</h4>
<ul>
<li>当在表上面定义了<code>PRIMARY KEY</code>之后，InnoDB会把它作为聚集索引。为此，为你的每个表定义一个<code>PRIMARY KEY</code>。如果没有唯一并且非空的字段或者一组列，那么请添加一个自增列；</li>
<li>如果您没有为表定义<code>PRIMARY KEY</code>，则MySQL会找到第一个不带null值的UNIQUE索引，并其用作聚集索引；</li>
<li>如果表没有<code>PRIMARY KEY</code>或没有合适的<code>UNIQUE</code>索引，则<code>InnoDB</code> 内部会生成一个隐藏的聚集索引<code>GEN_CLUST_INDEX</code>，作为行ID，行ID是一个6字节的字段，随着数据的插入而自增。</li>
</ul>
<h4 id="聚集索引查找">聚集索引查找</h4>
<p>根据索引进行查找id=50的记录，如下图，沿着B+树一直往下寻找，最终找到第四页**，然后把该页加载到buffer pool中，在缓存中遍历对比查找**，由于里面的行记录是顺序组织的，所以很快就可以定位到记录了。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101911287-192488000.png" alt="img" loading="lazy" ></p>
<h3 id="372辅助索引">3.7.2、辅助索引</h3>
<p>除了聚集索引之外的所有索引都称为辅助索引(二级索引)。在InnoDB中，辅助索引中每个记录都包含该行的主键列以及为辅助索引指定的列。</p>
<p>在辅助索引中查找到记录，可以得到记录的主键索引ID，然后可以通过这个主键索引ID去聚集索引中搜索具体的记录，这个过程称为<strong>回表</strong>操作。</p>
<p><strong>如果主键较长，则辅助索引将使用更多空间，因此具有短的主键是有利的。</strong></p>
<p>下面我们给刚刚的表添加一个组合联合索引</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#75715e">-- 添加多一个字段
</span><span style="color:#75715e"></span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t20 <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">column</span> d varchar(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">default</span> <span style="color:#e6db74">&#39;&#39;</span>;
<span style="color:#75715e">-- 添加一个联合索引
</span><span style="color:#75715e"></span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t20 <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span> idx_abc(a, b, <span style="color:#66d9ef">c</span>);
</code></pre></div><p>添加之后组合索引B+树如下，其中索引key为abc三个字段的组合，索引存储的记录为主键ID：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101933150-789168391.png" alt="img" loading="lazy" ></p>
<h4 id="覆盖索引using-index">覆盖索引(Using index)</h4>
<p>InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要回表去查询聚集索引中的记录，从而减少大量的IO操作。下面的查询既是用到了覆盖索引 idx_abc：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> a, b <span style="color:#66d9ef">from</span> t20 <span style="color:#66d9ef">where</span> a <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>;
</code></pre></div><p>执行结果如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605101955080-961209289.png" alt="img" loading="lazy" ></p>
<p>可以发现，Extra这一列提示Using index，使用到了覆盖索引，扫描的行数为2。<strong>注意：这里的扫描行数指的是MySQL执行器从引擎取到两条记录，引擎内部可能会遍历到多条记录进行条件比较。</strong></p>
<h4 id="最左匹配原则">最左匹配原则</h4>
<p>由于InnoDB索引式B+树构建的，因此可以利用索引的“最左前缀”来定位记录。</p>
<p>也就是说，不仅仅是用到索引的全部定义字段会走索引，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左n个字段。</p>
<h4 id="索引条件下推using-index-condition">索引条件下推(Using index condition)</h4>
<p>索引条件下推 <a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">Index Condition Pushdown</a> (ICP)，是针对MySQL使用索引从表中检索行的情况的一种优化。</p>
<p><strong>为什么叫下推呢，就是在满足要求的情况下，把索引的条件丢给存储引擎去判断，而不是把完整的记录传回MySQL Server层去判断。</strong></p>
<p>ICP支持<a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_range"><code>range</code></a>, <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref"><code>ref</code></a>, <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a>, 和 <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref_or_null"><code>ref_or_null</code></a>类型的查找，支持MyISAM和InnoDB存储引擎。</p>
<p>不能将引用子查询的条件下推，触发条件不能下推。详细规则参考：<a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">Index Condition Pushdown</a></p>
<p>如果不使用ICP，则存储引擎将遍历索引以在聚集索引中定位行，并将结果返回给MySQL Server层，MySQL Server层继续根据<code>WHERE</code>条件进行筛选行。</p>
<p>启用ICP后，如果<code>WHERE</code>可以仅使用索引中的列来评估部分条件，则MySQL Server层会将这部分条件压入<code>WHERE</code>条件下降到存储引擎。然后，存储引擎通过使用索引条目来判断索引条件，在满足条件的情况下，才回表去查找记录返回给MySQL Server层。</p>
<p><strong>ICP的目标是减少回表扫描的行数，从而减少I / O操作。对于<code>InnoDB</code>表，ICP仅用于二级索引。</strong></p>
<p>使用索引下推的时候，执行计划中的Extra会提示：<code>Using index condition</code>，而不是<code>Using index</code>，因为必须回表查询整行数据。<code>Using index</code>代表使用到了覆盖索引。</p>
<h2 id="38innodb-data-directory">3.8、InnoDB Data Directory</h2>
<p>InnoDB数据字典(Data Directory)存放于系统表空间中，主要包含元数据，用于追踪表、索引、表字段等信息。由于历史的原因，InnoDB数据字典中的元数据与<code>.frm</code>文件中的元数据重复了。</p>
<h2 id="39doublewrite-buffer">3.9、Doublewrite Buffer</h2>
<p>双写缓冲区(Doublewrite Buffer)是一个存储区，是InnoDB在tablespace上的128个页（2个区），大小是2MB[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn18">18]</a>。</p>
<blockquote>
<p>版本区别：在MySQL 8.0.20之前，doublewrite缓冲区存储区位于<code>InnoDB</code>系统表空间中。从MySQL 8.0.20开始，doublewrite缓冲区存储区位于doublewrite文件中。</p>
<p>本文基于MySQL 5.7编写。</p>
</blockquote>
<p>操作系统写文件是以4KB为单位的，那么每写一个InnoDB的page到磁盘上，操作系统需要写4个块。如果写入4个块的过程中出现系统崩溃，那么会导致16K的数据只有一部分写是成功的，这种情况下就是<code>partial page write</code>（部分页写入）问题。</p>
<p>InnoDB这个时候是没法通过redo log来恢复的，因为这个时候页面的<code>Fil Trailer</code>（Fil Trailer 主要存放<code>FIL_PAGE_END_LSN</code>，主要包含页面校验和以及最后的事务）中的数据是有问题的。</p>
<p>为此，每当InnoDB将页面写入到数据文件中的适当位置之前，都会首先将其写入双写缓冲区。只有将缓冲区安全地刷新到磁盘后，InnoDB才会将页面写入最终的数据文件。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102139274-1635627021.png" alt="img" loading="lazy" ></p>
<p>如果在页面写入过程中发生操作系统或者mysqld进程崩溃，则InnoDB可以在崩溃恢复期间从双写缓冲区中找到页面的完好副本用于恢复。恢复时，InnoDB扫描双写缓冲区，并为缓冲区中的每个有效页面检查数据文件中的页面是否完整。</p>
<p>如果系统表空间文件（“ ibdata文件 ”）位于支持原子写的Fusion-io设备上，则自动禁用双写缓冲，并且将Fusion-io原子写用于所有数据文件。</p>
<h2 id="310redo-log">3.10、Redo Log</h2>
<p>重做日志(Redo Log)主要适用于数据库的崩溃恢复，用于实现数据的完整性。</p>
<p>重做日志由两部分组成：</p>
<ul>
<li>重做日志缓冲区 Log Buffer；</li>
<li>重做日志文件，重做日志文件在磁盘上由两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的物理文件表示。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102203485-471513692.png" alt="img" loading="lazy" ></p>
<p><strong>为了实现数据完整性，在脏页刷新到磁盘之前，必须先把重做日志写入到磁盘。除了数据页，聚集索引、辅助索引以及Undo Log都需要记录重做日志。</strong></p>
<h3 id="3101redo-log在事务中的写入时机">3.10.1、Redo Log在事务中的写入时机</h3>
<p>在事务中，除了写Redo log，还需要写binlog，为此，我们先来简单介绍下binlog。</p>
<h4 id="31011binlog">3.10.1.1、binlog</h4>
<p>全写：Binary Log，二进制log。二进制日志是一组日志文件。其中包含有关对MySQL服务器实例进行的数据修改的信息。</p>
<p><strong>Redo Log是InnoDB引擎特有的，而binlog是MySQL的Server层实现的，所有引擎都可以使用。</strong></p>
<p><strong>Redo Log的文件是循环写的，空间会用完，binlog日志是追加写的，不会覆盖以前的日志。</strong></p>
<p><strong>binlog主要的目的：</strong></p>
<ul>
<li>主从同步，主服务器将二进制日志中包含的事件发送到从服务器，从服务器执行这些事件，以保持和主服务器相同的数据更改；</li>
<li>某些数据恢复操作需要使用二进制日志，还原到某一个备份点。</li>
</ul>
<p><strong>binlog主要是用于主从同步和数据恢复，Redo Log主要是用于实现事务数据的完整性，让InnoDB具有不会丢失数据的能力，又称为crash-safe。</strong></p>
<p><strong>binlog日志的两种记录形式：</strong></p>
<ul>
<li>基于SQL的日志记录：事件包含产生数据更改(插入，新增，删除)的SQL语句；</li>
<li>基于行的日志记录：时间描述对单个行的更改。</li>
</ul>
<p>混合日志记录默认情况下使用基于语句的日志记录，但根据需要自动切换到基于行的日志记录。</p>
<h4 id="31012redo-log在事务中的写入时机">3.10.1.2、Redo Log在事务中的写入时机</h4>
<p>简单的介绍完binlog，我们再来看看Redo Log的写入流程。</p>
<p>假设我们这里执行一条sql</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">update</span> t20 <span style="color:#66d9ef">set</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span> <span style="color:#66d9ef">where</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</code></pre></div><p>执行流程如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102225258-423792681.png" alt="img" loading="lazy" ></p>
<h3 id="3102如何保证数据不丢失">3.10.2、如何保证数据不丢失</h3>
<p>前面我们介绍<code>Log Buffer</code>的时候，提到过，为了保证数据不丢失，我们需要执行以下操作：</p>
<ul>
<li>如果启用了binlog，则设置：sync_binlog=1;</li>
<li>innodb_flush_log_at_trx_commit=1;</li>
</ul>
<blockquote>
<ul>
<li>sync_binlog=0：表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1：表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) ：表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
</blockquote>
<p>这两个的作用相当于在上面的流程最后一步，提交事务接口返回Server层之前，把binlog cache和log buffer都fsync到磁盘中了，这样就保证了数据的落盘，不会丢失，即使奔溃了，也可以通过binlog和redo log恢复数据相关流程如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102252346-2078895062.png" alt="img" loading="lazy" ></p>
<p>在磁盘和内存中的处理流程如下面编号所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102311335-477834857.png" alt="img" loading="lazy" ></p>
<p><strong>其中第四步log buffer持久化到磁盘的时机为：</strong></p>
<ul>
<li>log buffer占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程主动写盘；</li>
<li>InnoDB后台有个线程，每隔1秒会把log buffer刷到磁盘；</li>
<li>由于log buffer是所有线程共享的，当其他事务线程提交时也会导致已写入log buffer但还未提交的事务的redo log一起刷新到磁盘</li>
</ul>
<p><strong>其中第五步：脏页刷新到磁盘的时机为：</strong></p>
<ul>
<li>系统内存不足，需要淘汰脏页的时候，要把脏页同步回磁盘；</li>
<li>MySQL空闲的时候；</li>
<li>MySQL正常关闭的时候，会把脏页flush到磁盘。</li>
</ul>
<blockquote>
<p>参数<code>innodb_max_dirty_pages_pct</code>是脏页比例上限，默认值是 75%。</p>
</blockquote>
<p><strong>为什么第二步 redo log prepare状态也要写磁盘？</strong></p>
<p>因为这里先写了，才能确保在把binlog写到磁盘后崩溃，能够恢复数据：如果判断到redo log是prepare状态，那么查看是否存XID对应的binlog，如果存在，则表示事务成功提交，需要用prepare状态的redo log进行恢复。</p>
<p><strong>这样即使崩溃了，也可以通过redo log来进行恢复了，恢复流程如下：</strong></p>
<p>Redo Log是循环写的，如下图:</p>
<ul>
<li>writepos记录了当前写的位置，一边写位置一边往前推进，当writepos与checkpoint重叠的时候就表示logfile写满了，绿色部分表示是空闲的空间，红色部分是写了redo log的空间；</li>
<li>checkpoint处标识了当前的<code>LSN</code>，每当系统崩溃重启，都会从当前checkpoint这个位置执行重做日志，根据重做日志逐个确认数据页是否没问题，有问题就通过redo log进行修复。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102334416-858015776.png" alt="img" loading="lazy" ></p>
<blockquote>
<p>LSN Log Sequence Number的缩写。代表日志序列号。在InnoDB中，LSN占用8个字节，单调递增，LSN的含义：</p>
<ul>
<li>重做日志写入的总量；</li>
<li>checkpoint的位置；</li>
<li>页的版本；</li>
</ul>
<p>除了重做日志中有LSN，每个页的头部也是有存储了该页的LSN，我们前面介绍页面格式的时候有介绍过。</p>
<p>在页中LSN表示该页最后刷新时LSN的大小。[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn19">19]</a></p>
</blockquote>
<h2 id="311undo-logs">3.11、Undo Logs</h2>
<p>上面说的<strong>redo log记录了事务的行为，可以通过其对页进行重做操作，但是食物有时候需要进行回滚，这时候就需要undo log了</strong>。[<a href="https://www.cnblogs.com/arthinking/p/13034126.html#fn20">20]</a></p>
<p>**关于Undo Log的存储：**InnoDB中有回滚段(rollback segment)，每个回滚段记录1024个undo log segment，在每个undo log segment段中进行申请undo页。系统表空间偏移量为5的页记录了所有的rollback segment header所在的页。</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102353202-1256742611.png" alt="img" loading="lazy" ></p>
<h3 id="3111undo-log的格式">3.11.1、undo log的格式</h3>
<p>根据行为不同分为两种：</p>
<p><strong>insert undo log</strong></p>
<p><code>insert undo log</code>：只对事务本身可见，所以insert undo log在事务提交后可直接删除，无需执行purge操作；</p>
<p>insert undo log主要记录了：</p>
<table>
<thead>
<tr>
<th>next</th>
<th>记录下一个undo log的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>type_cmpl</td>
<td>undo的类型：insert or update</td>
</tr>
<tr>
<td>*undo_no</td>
<td>记录事务的ID</td>
</tr>
<tr>
<td>*table_id</td>
<td>记录表对象</td>
</tr>
<tr>
<td>*len1, col1</td>
<td>记录列和值</td>
</tr>
<tr>
<td>*len2, col2</td>
<td>记录列和值</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
<tr>
<td>start</td>
<td>记录undo log的开始位置</td>
</tr>
</tbody>
</table>
<p>假设在事务1001中，执行以下sql，t20的table_id为10：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t20(id, a, b, <span style="color:#66d9ef">c</span>, d) <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;init&#34;</span>)
</code></pre></div><p>那么对应会生成一条undo log：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102414603-1040461748.png" alt="img" loading="lazy" ></p>
<p><strong>update undo log</strong></p>
<p><code>update undo log</code>：执行update或者delete会产生undo log，会影响已存在的记录，为了实现MVCC(后边介绍)，update undo log不能再事务提交时立刻删除，<strong>需要将事务提交时放入到history list上，等待purge线程进行最后的删除操作。</strong></p>
<p>update undo log主要记录了：</p>
<table>
<thead>
<tr>
<th>next</th>
<th>记录下一个undo log的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>type_cmpl</td>
<td>undo的类型：insert or update</td>
</tr>
<tr>
<td>*undo_no</td>
<td>undo日志编号</td>
</tr>
<tr>
<td>*table_id</td>
<td>记录表对象</td>
</tr>
<tr>
<td>info_bits</td>
<td></td>
</tr>
<tr>
<td>*DATA_TRX_ID</td>
<td>事务的ID</td>
</tr>
<tr>
<td>*DATA_ROLL_PTR</td>
<td>回滚指针</td>
</tr>
<tr>
<td>*len1, i_col1</td>
<td>n_unique_index</td>
</tr>
<tr>
<td>*len2, i_col2</td>
<td></td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
</tr>
<tr>
<td>n_update_fields</td>
<td>以下是update vector信息，表示update操作导致发送改变的列</td>
</tr>
<tr>
<td>*pos1, *len1, u_old_col1</td>
<td></td>
</tr>
<tr>
<td>*pos2, *len2, u_old_col2</td>
<td></td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
</tr>
<tr>
<td>n_bytes_below</td>
<td></td>
</tr>
<tr>
<td>*pos, *len, col1</td>
<td></td>
</tr>
<tr>
<td>*pos, *len, col2</td>
<td></td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
</tr>
<tr>
<td>start</td>
<td>记录undo log的开始位置</td>
</tr>
</tbody>
</table>
<p>假设在事务1002中，执行以下sql，t20的table_id为10：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">update</span> t20 <span style="color:#66d9ef">set</span> d<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;update1&#34;</span> <span style="color:#66d9ef">where</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">60</span>;
</code></pre></div><p>那么对应会生成一条undo log：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102434891-1147852787.png" alt="img" loading="lazy" ></p>
<p>如上图，<strong>每回退应用一个undo log，就回退一个版本，这就是MVCC(Multi versioning concurrency control)的实现原理。</strong></p>
<p>下面我们在执行一个delete sql：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> t20 <span style="color:#66d9ef">where</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">60</span>;
</code></pre></div><p>对应的undo log变为如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102459002-1634947968.png" alt="img" loading="lazy" ></p>
<p>如上图，实际的行记录不会立刻删除，而是在行记录头信息记录了一个<code>deleted_flag</code>标志位。最终会在purge线程purge undo log的时候进行实际的删除操作，这个时候undo log也会清理掉。</p>
<h3 id="3112mvcc实现原理">3.11.2、MVCC实现原理</h3>
<p>如上图所示，MySQL只会有一个行记录，但是会把每次执行的sql导致行记录的变动，通过undo log的形式记录起来，undo log通过回滚指针连接在一起，这样我们想回溯某一个版本的时候，就可以应用undo log，回到对应的版本视图了。</p>
<p>我们知道InnoDB是支持<code>RC</code>(Read Commit)和<code>RR</code>(Repeatable Read)事务隔离级别的，而这个是通过<code>一致性视图</code>(consistent read view)实现的。</p>
<p>一个事务开启瞬间，所有活跃的事务(未提交)构成了一个视图数组，InnoDB就是通过这个视图数组来判断行数据是否需要undo到指定的版本：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102520435-392894450.png" alt="img" loading="lazy" ></p>
<h5 id="rr事务隔离级别">RR事务隔离级别</h5>
<p>假设我们使用了<strong>RR事务隔离级别</strong>。我们看个例子：</p>
<p>如下图，假设id=60的记录a=1</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102539609-348854978.png" alt="img" loading="lazy" ></p>
<p>事务C启动的瞬间，活跃的事务如下图黄色部分所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102558472-875730629.png" alt="img" loading="lazy" ></p>
<p>也就是对于事务A、事务B、事务C，他们能够看到的数据只有是行记录中的最大事务ID<code>DATA_TRX_ID</code>&lt;=11的，如果大于，那么只能通过undo进行回滚了。如果TRX_ID=当前事务id，也可以看到，即看到自己的改动。</p>
<p>另外有一个需要注意的：</p>
<ul>
<li><strong>在RR隔离级别下，当事务更新事务的时候，只能用当前读来获取最新的版本数据来更新，如果当前记录的行锁被其他事务占用，就需要进入所等待；</strong></li>
<li><strong>在RC隔离级别下，每个语句执行都会计算出新的一致性视图。</strong></li>
</ul>
<p>所以我们分析上面的例子的执行流程：</p>
<ul>
<li>事务C执行update，执行当前读，拿到的a=1，然后+1，最终a=2，同时添加一个TRX_ID=11的undo log；
<ul>
<li><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102623218-200549937.png" alt="img" loading="lazy" ></li>
</ul>
</li>
<li>事务B执行select，使用快照读，记录的DATA_TRX_ID &gt; 11，所以需要通过undo log回滚到DATA_TRX_ID=11的版本，所以拿到的a是1；</li>
<li>事务B执行update，需要使用当前读，拿到最新的记录，a=2，然后加1，最终a=3；
<ul>
<li><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102648628-1980888763.png" alt="img" loading="lazy" ></li>
</ul>
</li>
<li>事务B执行select，拿到当前最新的版本，为自己的事务id，所以得到a=3；</li>
<li>事务A执行select，使用快照读，记录的DATA_TRX_ID &gt; 11，所以需要通过undo log回滚到DATA_TRX_ID=11的版本，所以拿到的a是1。</li>
<li>如果是RC隔离级别，执行select的时候会计算出新的视图，新的视图能够看到的最大事务ID=14，由于事务B还没提交，事务C提交了，所以可以得到a=2：
<ul>
<li><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102724121-1152948631.png" alt="img" loading="lazy" ></li>
</ul>
</li>
</ul>
<h1 id="总结">总结</h1>
<ul>
<li>数据完整性依靠：redo log</li>
<li>事务隔离级别的实现依靠MVCC，MVCC依靠undo log实现</li>
<li>IO性能提升方式：buffer pool加快查询效率和普通索引更新的效率，log buffer对日志写的性能提升</li>
<li>查询性能提升依赖于索引，底层用页存储，字段越小页存储越多行记录，查询效率越快；自增字段作为聚集索引可以加快插入操作；</li>
<li>故障恢复：双写缓冲区、redo log</li>
<li>主从同步：binlog</li>
</ul>
<p>本文内容比较多，看完之后需要多梳理，最后大家可以对照着这个思维导图回忆一下，这些内容是否都记住了：</p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102752183-2113968595.png" alt="img" loading="lazy" ></p>
<p><img src="https://img2020.cnblogs.com/blog/494394/202006/494394-20200605102809109-1418527627.png" alt="img" loading="lazy" ></p>
<hr>
<p>这篇文章的内容就差不多介绍到这里了，能够阅读到这里的朋友真的是很有耐心，为你点个赞。</p>
<p>本文为<code>arthinking</code>基于相关技术资料和官方文档撰写而成，确保内容的准确性，如果你发现了有何错漏之处，烦请高抬贵手帮忙指正，万分感激。</p>
<p>大家可以关注我的博客：<code>itzhai.com</code> 获取更多文章，我将持续更新后端相关技术，涉及JVM、Java基础、架构设计、网络编程、数据结构、数据库、算法、并发编程、分布式系统等相关内容。</p>
<p>如果您觉得读完本文有所收获的话，可以<code>关注</code>我的账号，或者<code>点赞</code>吧，码字不易，您的支持就是我写作的最大动力，再次感谢！</p>

    </div>

    <div class="post-copyright">
            
            <p class="copyright-item">
                <span>Author:</span>
                <span>Rockwinder </span>
                </p>
            

            
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://rockwinder.github.io/post/mysql_underlying_architecture/>https://rockwinder.github.io/post/mysql_underlying_architecture/</span>
            </p>
            
            
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>


    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> ·
                <span><a href="https://rockwinder.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://rockwinder.github.io/post/macos_gdb_install/" class="prev" rel="prev" title="在macOS上使用GDB的教程"><i class="iconfont icon-left"></i>&nbsp;在macOS上使用GDB的教程</a>
        
        
        <a href="https://rockwinder.github.io/post/how_to_learn_linux_embedded/" class="next" rel="next" title="如何学习嵌入式linux">如何学习嵌入式linux&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
            
                <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.bootcss.com/gitalk/1.5.2/gitalk.css">
<script src="https://cdn.bootcss.com/gitalk/1.5.2/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({

        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: location.pathname, 
        distractionFreeMode: false 
    });
    (function () {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>

            
        
    </div>
</article>
                </div>
            </main>
            <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2017 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i>
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://rockwinder.github.io/">Rockwinder</a> | </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/Mogeko/Mogege" target="_blank" rel="external nofollow">Mogege</a></span>
    </div>
</footer>





>
<script defer src="/js/vendor_main.min.js"></script>







<script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script> pangu.spacingPage();</script>





        </div>
    </body>
</html>
